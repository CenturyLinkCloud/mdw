<html>
<head>
<title>Using Adapter Activities</title>
<link rel="stylesheet" type="text/css" href="docstyle.css"/>
<style>
var {
  font-style: italic;
  color: #0000a0;
}
dfn { color: brown; }
</style>
</head>
<body>
<h1>Using Adapter Activities</h1>
<p>The class <code>AdapterActivityBase</code> is an abstract
class that provides common base for all adapter activities,
and most activities extend this base class directly.</p>

<p>The adapters can be directly used in connection pools, and support automatic
retries through adapter configuration, rather than a retry loop (a link from
it to itself) as typically used with old implementors.
In order to keep backward compatibility, we introduced a new
base class, <code>PoolableAdapterBase</code>, to support the new functionalities.
Adapters defined on top of the new base class are called <dfn>poolable adapters</dfn>.
A poolable adapter can therefore be used in two ways:</p>
<ul>
   <li>Used directly as an activity. Activities that
       use these adapters directly are called <dfn>direct connection
   		adapter activities</dfn>.
   <li>Used via a connection pool. The connection pool should be configured
   		to use the adapter, and the process should use the activity implementor
   		<a href='ConnectionPoolAdapter.html'>ConnectionPoolAdapter</a> or its
   		subclasses which interface with connection pools.
   		Such activity implementors are called <dfn>pooled connection 
   		adapter activities</dfn>.</li>
</ul>
<p>MDW provides a set of common adapters for common protocols such
as SOAP based MDW web services, JMS, as well as the adapter activity using connection pools, mentioned above.
These adapters are highly configurable and hence
can meet common needs in many cases. You may however
encounter situations where further customization beyond configuration is needed.
Here is a list of common reasons:</p>
<ul>
  <li>The built-in adapters all take requests (messages to be sent to
    external systems) from a process variable, specified during configuration.
    If there is a need to get request messages from a place other than a variable,
    it can be achieved by overriding the <code>getRequestData</code>
    method to be described below.</li>
  <li>Similarly, the built-in adapters all put responses (messages received
    as responses from external systems in synchronous transport protocols)
    an a configured process variable. If there is a need to store the responses
    elsewhere, it can be achieved by overriding the method <code>onSuccess</code>.
    This method may also be needed to perform custom logics such as extracting
    or translating the responses before persistence.</li>
  <li>The built-in adapters consider reception of any response data from
    the external systems as a success, even though the response may
    indicate an error condition and may need to be retried, because such
    knowledge is external systems specific. It is common to have a need
    to convert the seemingly successful responses into failures (retriable
    and non-retriable). This can be achieved by overriding the method <code>invoke</code>.</li>
  <li>Performing custom retry logic and other business logic in case of failure:
    you can override the method <code>onFailure</code>.</li>   
  <li>Passing meta information in addition to the request messages. Meta data
    are transport protocol specific. Example is correlation ID for
    JMS adapter, in addition to the standard <code>DATA</code> field for request data.</li>
  <li>You may have a need to send messages to a system using a protocol
    not supported by any of the built-in adapters. One common case is invoking
    SOAP-based web services. In this case you will need to implement
    a brand new adapter by extending <code>PoolableAdapterBase</code>
    directly.</li>
</ul>
<p>The next section describes such customizations in details.</p>

<h2>Implementing Poolable Adapters</h2>
<p>A new poolable adapter should extend the abstract base class
<code>com.centurylink.mdw.workflow.adapter.PoolableAdapterBase</code>.
The following describes the methods you must implement or may extend.</p>
<li><code>void init()</code>.
This method is invoked by adapter activities only.
Typically the method should set configuration parameters from attributes
and their default values. Note that the invoke method should
not call <code>getAttributeValue</code> to get configuration
parameters as the method is not available when used in a connection pool.
All activity attributes must be set as Java instance variables in this method.
The following is the implementation of the connection pool adapter:
<pre>
    @Override
    public void init() throws ConnectionException, AdapterException {
        String pool_name = this.getAttributeValue(POOL_NAME);
        if (pool_name==null) throw new AdapterException("Pool name not specified");
        pool = ConnectionPoolRegistration.getPool(pool_name);
        if (pool==null) throw new AdapterException("Connection pool not defined: " + pool_name);
    }
</pre>
</li>

<li><code>Object openConnection()</code>. 
This method is to be implemented to open a communication channel
with the external system. It is invoked by an adapter activity
when it opens a connection, right after the call to <code>init()</code>.
When it is used with connection pools,
with one-connection-for-all style,
the method is invoked by the pool manager immediately after
the <code>init()</code> call when a new connection instance is created.
With one-connection-per-call style, the method is invoked
right before a message is to be sent.
Its implementation typically remembers the object representing
the open connection in a Java instance variable.
The method can throw <code>ConnectionException</code> or <code>AdapterException</code>.
See the description for <code>invoke</code> method for their differences.
The method should return an object identifying the open connection, and the
object will passed to <code>invoke</code> and <code>closeConnection</code> methods.
It is typical to return the adapter class instance itself.
The following is the implementation of the connection pool adapter:
<pre>
   @Override
    public Object openConnection() throws ConnectionException,AdapterException {
        exceptionCode = 0;
        if (fromResume) {
            return pool.getReservedConnection(logtag(), this.getActivityInstanceId());
        } else {
            return pool.getConnection(logtag(), this.getActivityInstanceId());
        }
    }
</pre>
</li>

<li><code>void closeConnection(Object connection)</code>. 
The method should close the connection with the external system opened by <code>openConnection</code>.
The method is invoked by an adapter activity when it is closing a connection
after the message is sent.
When it is used with a connection pool,
with one-connection-for-all style,
the method is invoked by the pool manager when the connection is removed from the connection
pool.
With one-connection-per-call style, the method is invoked
right after a message is sent.
The only argument is passed in with object returned by <code>openConnection</code>.
</li>
<li><code>String invoke(Object connection, String message, int timeout, Map&lt;String,String> meta_data)</code>. 
You will need to implement this method to actually send a message.
It should also wait for responses for synchronous.
The timeout value is in seconds. The implementation should allow a value less than 0
to use the global value specified in the configuration parameter <code>timeout</code>,
or a hard-coded default value when the configuration parameter is absent.
<p>
In case of error detected, the method should:
	<ul>
 		<li>Throw ConnectionException when it is expecting the connection pool adapter to retry automatically. The type of error must
 			be retriable (typically for connectivity issues). If you use a constructor
 			for ConnectionException that takes an error code, you should set
 			it to <code>ConnectionException.CONNECTION_DOWN</code> (41290) if the exception
 			is used to count for automatic shutdown after consecutively receiving such exceptions.
 			The single argument constructor sets this code by default.
 			</li>
 		<li>Throw AdapterException when the error is not retriable, such as data error
 			that can only be fixed by manual intervention elsewhere. If the message is synchronous,
 			the method is typically invoked by a connection pool adapter, which will lead to
 			an error transition, typically end up in exception handler.</li>
	</ul>

The following is the implementation of the connection pool adapter:
<pre>
    @Override
    public String invoke(Object conn, String requestData, int timeout, Map<String,String> meta_data)
        throws AdapterException, ConnectionException
    {
        String result;

        if (this.isSynchronous()) {
            PooledAdapterConnection connection = (PooledAdapterConnection)conn;
            result = connection.invoke((String)requestData, timeout, meta_data);
        } else {
            PooledAdapterConnection connection = (PooledAdapterConnection)conn;
            connection.invoke(requestData, -1, meta_data);
            result = null;
        }
        return result;
    }
</pre>
</li>
<li><code>boolean ping()</code>.
This method is only used by connection pools.
 The method is for pinging the external system after the pool
 is automatically shut down due to consecutive connection failures.
 The method should return true when the connection with the 
 external system is up, and false otherwise.
The following example method returns true if the connection is up and false if it is still down:
<pre>
    protected boolean ping() {
        if (one_connection_for_all) {
            return adapter.ping(pool.getPingTimeout());
        } else {
            Object connection = null;
            try {
                connection = adapter.openConnection();
                return adapter.ping(pool.getPingTimeout());
            } catch (Exception e) {
                return false;
            } finally {
                if (connection!=null) adapter.closeConnection(connection);
            }
        }
    }
</pre>
</li>
<li><code>String getLabel()</code>: The method is used
by the designer to obtain the label for the activity implementor.
You typically should override this method to return a unique and descriptive
name for the adapter. Here is an example:
<pre>
    public String getLabel() {
        return getProcessName() + (getVersion() == 0 ? "" : " v" + getVersionString());
    }
</pre>
</li>
<li><code>boolean canBeSynchronous()</code>: you must implement this method. It should
return true if the adapter can be used synchronously (receiving a response), and false otherwise.
The following is an example:
<pre>
protected boolean canBeSynchronous() {
    return true;
}
</pre>
If the adapter can be used both synchronously and asynchronously, an option will be shown
in the activity configuration to choose between the two.
. And the method <code>isSynchronous</code>
is the API to determine whether the adapter is used synchronously (an adapter can support
both mode but can only be configured to use one.
</li>
<li><code>boolean canBeAsynchronous()</code>: you must implement this method. It should
return true if the adapter can be used asynchronously (sending a one way message without
expecting a reply), and false otherwise.
The following is an example:
<pre>
protected boolean canBeAsynchronous() {
    return true;
}
</pre>
</li>
</ul>
<p>The above are all the methods that you typically implement or override, which are shown as example above.
The following methods may be overridden less commonly:</p>
<ul>
<li><code>getRequestData()</code>: this method returns the request message. The default
implementation reads it from a variable configured in the designer. You can override it
to get the message from elsewhere.</li>
<li><code>onSuccess(String response)</code>: the method is invoked when the external system
returns a successful response. The method may convert external-system-detected errors into failure
by throwing an exception here (ConnectionException for retriable errors and
AdapterException for non-retriable errors), although it is preferable to perform such interpretation
in the method <code>invoke</code>, as the logic can be shared with connection pools.
Throwing an exception here
also triggers the method <code>onFailure</code> to be called.
This method is also the place to translate external responses
into internal format and persist them somewhere, if these are needed.
The default implementation stores the message in a variable configured in the designer.
</li>
<li><code>onFailure(int tryCount, int maxTries, Throwable errorCause)</code>: 
The method is invoked on the failure of each try.
The outcome of the method must be one of the following:
  <ul>
    <li>throw ConnectionException. The engine will put the activity in error status,
	    and schedule automatically retry of the activity.</li>
	<li>throw AdapterException. The engine will put the activity in error status,
	    and transition based on ERROR event (typically lead to exception handler).</li>
	<li>return a completion code w/o throwing exception. The engine will complete
	    the activity and transition accordingly.</li>
  </ul>
The default implementation does the following:
  <ul>
    <li>if <var>errorCause</var> is an AdapterException, throws it.</li>
    <li>if <var>errorCause</var> is a ConnectionException:
        <ul>
          <li>if <var>tryCount</var> (the number of tries already made) is less than 
          	<var>maxTries</var> (maximum allowed tries, as configured in the designer), throws it</li>
          <li>otherwise throws AdapterException with error code 
          	<code>AdapterConnectionPool.EXCEPTION_EXCEED_MAXTRIES</code>
        </ul></li>
    <li>in any other case, throw AdapterException with <var>errorCode</var> as its error code</li>
  </ul>
When you override this method, you would normally invoke this super method as the last thing,
to preserve the above logic.
</li>
</ul>
<p>You can look at built-in poolable adapters as samples.
We note that the built-in adapters typically do not throw exceptions when
it receives any messages from external systems, even the messages may indicate
some error conditions (e.g. an XML message that contains an error message).
This is obviously due to the fact that there is no generic way to identify what messages indicate
errors. When you implement your application-specific adapters, which you may
have knowledge as to what response messages indicate errors, you should throw
exceptions as described above appropriately, so that the auto-retry mechanism can
function properly. </p>

<h2>Implementing Pooled Connection Adapter Activities</h2>
<p>The built-in implementor <a href='ConnectionPoolAdapter.html'>ConnectionPoolAdapter</a>
is implemented as a subclass of <code>PoolableAdapterBase</code> as well,
even though itself is not really a poolable adapter
and should be never be used by a connection pool.
This is because it shares many common functionalities as direct connection
adapter activities. As a good consequence, you can customize the connection pool
adapter just like other adapters, as described above. Some methods only
used by connection pools are not meant to be overridden, such as <code>init(Properties)</code>,
and <code>ping</code>.  The methods that may need to be overridden include:</
<ul>
  <li><code>invoke</code></li>
  <li><code>onSuccess</code></li>
  <li><code>onFailure</code></li>
  <li><code>getRequestData</code></li>
</ul>
</body>
</html>
