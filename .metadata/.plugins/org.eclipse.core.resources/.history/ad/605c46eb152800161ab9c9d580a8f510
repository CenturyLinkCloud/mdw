/**
 * Copyright (c) 2016 CenturyLink, Inc. All Rights Reserved.
 */
package com.centurylink.mdw.services.workflow;

import java.sql.SQLException;
import java.util.Date;
import java.util.List;
import java.util.Map;

import com.centurylink.mdw.common.exception.DataAccessException;
import com.centurylink.mdw.common.service.Query;
import com.centurylink.mdw.common.service.ServiceException;
import com.centurylink.mdw.common.utilities.TransactionWrapper;
import com.centurylink.mdw.common.utilities.logger.LoggerUtil;
import com.centurylink.mdw.common.utilities.logger.StandardLogger;
import com.centurylink.mdw.common.utilities.timer.CodeTimer;
import com.centurylink.mdw.dataaccess.DataAccess;
import com.centurylink.mdw.dataaccess.DatabaseAccess;
import com.centurylink.mdw.dataaccess.RuntimeDataAccess;
import com.centurylink.mdw.dataaccess.file.AggregateDataAccessVcs;
import com.centurylink.mdw.dataaccess.version4.CommonDataAccess;
import com.centurylink.mdw.model.value.activity.ActivityInstance;
import com.centurylink.mdw.model.value.activity.ActivityList;
import com.centurylink.mdw.model.value.activity.ActivityVO;
import com.centurylink.mdw.model.value.attribute.AssetVersionSpec;
import com.centurylink.mdw.model.value.attribute.RuleSetVO;
import com.centurylink.mdw.model.value.process.ProcessCount;
import com.centurylink.mdw.model.value.process.ProcessInstanceVO;
import com.centurylink.mdw.model.value.process.ProcessList;
import com.centurylink.mdw.model.value.process.ProcessVO;
import com.centurylink.mdw.model.value.task.TaskInstanceVO;
import com.centurylink.mdw.model.value.user.UserActionVO.Action;
import com.centurylink.mdw.model.value.work.ActivityInstanceVO;
import com.centurylink.mdw.services.ServiceLocator;
import com.centurylink.mdw.services.TaskManager;
import com.centurylink.mdw.services.WorkflowServices;
import com.centurylink.mdw.services.dao.process.EngineDataAccessDB;
import com.centurylink.mdw.services.dao.process.cache.ProcessVOCache;

public class WorkflowServicesImpl implements WorkflowServices {

    private static StandardLogger logger = LoggerUtil.getStandardLogger();

    protected RuntimeDataAccess getRuntimeDataAccess() throws DataAccessException {
        return DataAccess.getRuntimeDataAccess(new DatabaseAccess(null));
    }

    protected AggregateDataAccessVcs getAggregateDataAccess() throws DataAccessException {
        return new AggregateDataAccessVcs();
    }

    public Map<String,String> getAttributes(String ownerType, Long ownerId) throws ServiceException {
        try {
            return ServiceLocator.getEventManager().getAttributes(ownerType, ownerId);
        }
        catch (Exception ex) {
            throw new ServiceException(ex.getMessage(), ex);
        }
    }

    public void setAttributes(String ownerType, Long ownerId, Map<String,String> attributes) throws ServiceException {
        try {
            ServiceLocator.getEventManager().setAttributes(ownerType, ownerId, attributes);
        }
        catch (Exception ex) {
            throw new ServiceException(ex.getMessage(), ex);
        }
    }
    /**
     * Update attributes without deleting all attributes for this ownerId first
     */
    public void updateAttributes(String ownerType, Long ownerId, Map<String,String> attributes) throws ServiceException {
        try {
            for (Map.Entry<String, String> attribute : attributes.entrySet()) {
                String attributeName = attribute.getKey();
                String attributeValue = attribute.getValue();
                ServiceLocator.getEventManager().setAttribute(ownerType, ownerId, attributeName, attributeValue);
            }
        }
        catch (Exception ex) {
            throw new ServiceException(ex.getMessage(), ex);
        }
    }
    /**
     * Replace all existing values
     */
    public void setValues(String ownerType, String ownerId, Map<String,String> values) throws ServiceException {
        try {
            CommonDataAccess dao = new CommonDataAccess();
            dao.setValues(ownerType, ownerId, values);
        }
        catch (SQLException ex) {
            throw new ServiceException(ex.getMessage(), ex);
        }
    }

    /**
     * Update certain values
     */
    public void updateValues(String ownerType, String ownerId, Map<String,String> values) throws ServiceException {
        try {
            CommonDataAccess dao = new CommonDataAccess();
            for (String key : values.keySet())
                dao.setValue(ownerType, ownerId, key, values.get(key));
        }
        catch (SQLException ex) {
            throw new ServiceException(ex.getMessage(), ex);
        }
    }

    public Map<String,String> getValues(String ownerType, String ownerId) throws ServiceException {
        try {
            CommonDataAccess dao = new CommonDataAccess();
            return dao.getValues(ownerType, ownerId);
        }
        catch (SQLException ex) {
            throw new ServiceException(ex.getMessage(), ex);
        }
    }

    public List<String> getValueHolderIds(String valueName, String valuePattern) throws ServiceException {
        return getValueHolderIds(valueName, valuePattern, null);
    }

    public List<String> getValueHolderIds(String valueName, String valuePattern, String ownerType) throws ServiceException {
        try {
            CommonDataAccess dao = new CommonDataAccess();
            if (ownerType == null)
                return dao.getValueOwnerIds(valueName, valuePattern);
            else
                return dao.getValueOwnerIds(ownerType, valueName, valuePattern);
        }
        catch (SQLException ex) {
            throw new ServiceException(ex.getMessage(), ex);
        }
    }

    public void registerTaskWaitEvent(Long taskInstanceId, String eventName) throws ServiceException {
        registerTaskWaitEvent(taskInstanceId, eventName, "FINISH", false);
    }

    public void registerTaskWaitEvent(Long taskInstanceId, String eventName, String completionCode) throws ServiceException {
        registerTaskWaitEvent(taskInstanceId, eventName, completionCode, false);
    }

    // FIXME confirm this implementation
    public void registerTaskWaitEvent(Long taskInstanceId, String eventName, String completionCode,
            boolean recurring) throws ServiceException {
        TransactionWrapper tw = null;
        EngineDataAccessDB dataAccess = null;
        try {
            TaskManager taskMgr = ServiceLocator.getTaskManager();
            TaskInstanceVO taskVo = taskMgr.getTaskInstance(taskInstanceId);
            Long activityInstanceId = taskMgr.getActivityInstanceId(taskVo,false);
            dataAccess = new EngineDataAccessDB();
            tw = dataAccess.startTransaction();
            dataAccess.recordEventWait(eventName, !recurring, 3600, activityInstanceId, completionCode);
        }
        catch (Exception ex) {
            throw new ServiceException(ex.getMessage(), ex);

        }
        finally {
            if (tw != null)
                try {
                    dataAccess.stopTransaction(tw);
                }
                catch (DataAccessException ex) {
                    throw new ServiceException(ex.getMessage(), ex);
                }
        }
    }

    @Override
    public void actionActivity(String activityInstanceId, String action, String completionCode) throws ServiceException {
        try {
            if (action != null && (action.equalsIgnoreCase(Action.Proceed.toString()))){
                ServiceLocator.getEventManager().skipActivity(null, new Long(activityInstanceId).longValue(), completionCode);
            }
            else if (action != null && (action.equalsIgnoreCase(Action.Retry.toString()))){
                ActivityInstanceVO activityVo = ServiceLocator.getEventManager().getActivityInstance(new Long(activityInstanceId).longValue());
                ServiceLocator.getEventManager().retryActivity(activityVo.getDefinitionId(), new Long(activityInstanceId).longValue());
            }
        }
        catch (Exception ex) {
            throw new ServiceException(ex.getMessage(), ex);
        }
    }

    public static void main(String[] args){
        WorkflowServicesImpl workflowServicesImpl = new WorkflowServicesImpl();
                try {
                    workflowServicesImpl.registerTaskWaitEvent(1105L, "manoj-1105");
                }
                catch (ServiceException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
    }

    @Override
    public List<ActivityInstanceVO> getActivityInstances(String masterRequestId, String processName,
            String activityLogicalId) throws ServiceException {
        List<ActivityInstanceVO> activityInstanceVOList = null;
        try {
            activityInstanceVOList = ServiceLocator.getEventManager().getActivityInstances(masterRequestId, processName, activityLogicalId);
        }
        catch (Exception ex) {
            throw new ServiceException(ex.getMessage(), ex);
        }
        return activityInstanceVOList;
    }

    @Override
    public ActivityList getActivities(Query query) throws ServiceException {
        try {
            CodeTimer timer = new CodeTimer(true);
            ActivityList list = getAggregateDataAccess().getActivityInstanceList(query);
            timer.logTimingAndContinue("getAggregateDataAccess().getActivityInstanceList()");
            list = populateActivities(list);
            timer.stopAndLogTiming("WorkflowServicesImpl.populateActivities()");
            return list;
        }
        catch (DataAccessException ex) {
            throw new ServiceException(500, "Error retrieving activity instance for query: " + query, ex);
        }
    }

    @Override
    public ProcessInstanceVO getProcess(Long instanceId) throws ServiceException {
        try {
            return getRuntimeDataAccess().getProcessInstanceAll(instanceId);
        }
        catch (DataAccessException ex) {
            throw new ServiceException(500, "Error retrieving process instance: " + instanceId + ": " + ex.getMessage(), ex);
        }
    }

    @Override
    public ProcessList getProcesses(Query query) throws ServiceException {
        try {
            // TODO variables
            Map<String,String> criteria = query.getFilters();
            int pageIndex = query.getStart() / PAGE_SIZE;
            String orderBy = query.getSort();
            return getRuntimeDataAccess().getProcessInstanceList(criteria, null, pageIndex, PAGE_SIZE, orderBy);

        }
        catch (DataAccessException ex) {
            throw new ServiceException(500, "Error retrieving process instance for query: " + query, ex);
        }
    }

    public List<ProcessCount> getTopThroughputProcesses(Query query) throws ServiceException {
        try {
            CodeTimer timer = new CodeTimer(true);
            List<ProcessCount> list = getAggregateDataAccess().getTopThroughputProcessInstances(query);
            timer.logTimingAndContinue("AggregateDataAccessVcs.getTopThroughputProcessInstances()");
            list = populate(list);
            timer.stopAndLogTiming("WorkflowServicesImpl.populate()");
            return list;
        }
        catch (DataAccessException ex) {
            throw new ServiceException("Error retrieving top throughput processes: query=" + query, ex);
        }
    }

    public Map<Date,List<ProcessCount>> getProcessInstanceBreakdown(Query query) throws ServiceException {
        try {
            Map<Date,List<ProcessCount>> map = getAggregateDataAccess().getProcessInstanceBreakdown(query);
            if (query.getFilters().get("processIds") != null) {
                for (Date date : map.keySet())
                    populate(map.get(date));
            }
            return map;
        }
        catch (DataAccessException ex) {
            throw new ServiceException("Error retrieving process instance breakdown: query=" + query, ex);
        }
    }

    /**
     * Fills in process header info, consulting latest instance comment if necessary.
     */
    protected List<ProcessCount> populate(List<ProcessCount> processCounts) throws DataAccessException {
        AggregateDataAccessVcs dataAccess = null;
        for (ProcessCount pc : processCounts) {
            ProcessVO process = ProcessVOCache.getProcessVO(pc.getId());
            if (process == null) {
                logger.severe("Missing definition for process id: " + pc.getId());
                pc.setDefinitionMissing(true);
                // may have been deleted -- infer from comments
                if (dataAccess == null)
                    dataAccess = getAggregateDataAccess();
                CodeTimer timer = new CodeTimer(true);
                String comments = dataAccess.getLatestProcessInstanceComments(pc.getId());
                timer.stopAndLogTiming("getLatestProcessInstanceComments()");
                if (comments != null) {
                    AssetVersionSpec spec = AssetVersionSpec.parse(comments);
                    pc.setName(spec.getName());
                    pc.setVersion(spec.getVersion());
                    String pkgNameVer = spec.getPackageName();
                    if (pkgNameVer != null) {
                        int spaceV = pkgNameVer.indexOf(" v");
                        if (spaceV > 0 && pkgNameVer.length() > spaceV + 2)
                            pc.setPackageName(pkgNameVer.substring(0, spaceV));
                        else
                            pc.setPackageName(spec.getPackageName());
                    }
                }
                else {
                    logger.severe("Unable to infer process name for: " + pc.getId());
                    pc.setName("Unknown (" + pc.getId() + ")");
                }
            }
            else {
                pc.setName(process.getName());
                pc.setVersion(RuleSetVO.formatVersion(process.getVersion()));
                pc.setPackageName(process.getPackageName());
            }
        }
        return processCounts;
    }
    /**
     * Fills in process header info, consulting latest instance comment if necessary.
     */
    protected ActivityList populateActivities(ActivityList activityList) throws DataAccessException {
        AggregateDataAccessVcs dataAccess = null;
        List<ActivityInstance> aList = activityList.getActivities();
        for (ActivityInstance activityInstance : aList) {
            ProcessVO process = ProcessVOCache.getProcessVO(activityInstance.getProcessId());
            if (process == null) {
                logger.severe("Missing definition for process id: " + activityInstance.getProcessId());
                activityInstance.setDefinitionMissing(true);
                // may have been deleted -- infer from comments
                if (dataAccess == null)
                    dataAccess = getAggregateDataAccess();
                CodeTimer timer = new CodeTimer(true);
                String comments = dataAccess.getLatestProcessInstanceComments(activityInstance.getProcessId());
                timer.stopAndLogTiming("getLatestProcessInstanceComments()");
                if (comments != null) {
                    AssetVersionSpec spec = AssetVersionSpec.parse(comments);
                    activityInstance.setProcessName(spec.getName());
                    activityInstance.setVersion(spec.getVersion());
                    String pkgNameVer = spec.getPackageName();
                    if (pkgNameVer != null) {
                        int spaceV = pkgNameVer.indexOf(" v");
                        if (spaceV > 0 && pkgNameVer.length() > spaceV + 2)
                            activityInstance.setPackageName(pkgNameVer.substring(0, spaceV));
                        else
                            activityInstance.setPackageName(spec.getPackageName());
                    }
                }
                else {
                    logger.severe("Unable to infer process name for: " + activityInstance.getProcessId());
                    activityInstance.setProcessName("Unknown (" + activityInstance.getProcessId() + ")");
                }
                activityInstance.setActivityName("Unknown" + activityInstance.getDefinitionId());
            }
            else {
                activityInstance.setProcessName(process.getName());
                activityInstance.setVersion(RuleSetVO.formatVersion(process.getVersion()));
                activityInstance.setPackageName(process.getPackageName());
                ActivityVO actdef = process.getActivityByLogicalId('A' + activityInstance.getDefinitionId().toString());
                if (actdef != null)
                    activityInstance.setActivityName(actdef.getActivityName());
                else {
                    List<ProcessVO> subProcess = process.getSubProcesses();
                    for (ProcessVO subProcessVO : subProcess) {
                        actdef = subProcessVO.getActivityByLogicalId('A' + activityInstance.getDefinitionId().toString());
                        if (actdef != null){
                            activityInstance.setActivityName(actdef.getActivityName());
                            activityInstance.setProcessName(process.getName() + ":" + subProcessVO.getProcessName());
                            break;
                        }
                    }
                    if (actdef == null)
                        activityInstance.setActivityName("Unknown" + activityInstance.getDefinitionId());
                }
            }
        }
        return activityList;
    }
}
